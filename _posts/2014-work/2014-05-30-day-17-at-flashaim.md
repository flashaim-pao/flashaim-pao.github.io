---
layout: post
title: 'Day 17 at Flashaim'
date: 2014-05-30 01:49
image: ''
description: ''
categories:
    - 工作紀實
tags:
    - 新人日誌
    - 知識科技
 
---
# 路徑規劃
今天已實作好第一版的**分支設限法**演算法求解路徑規劃，而且透過昨天所作的單元測試進行測試。分支設限是由窮舉法（暴力法）所演變來，然而不是隨意一個窮舉法便可改為分支設限法，必須改寫為樹狀結構的窮舉法才行。所謂的分支，便是樹狀的分支。

# 分支
此問題為**排列問題**（另一種為**組合問題**），我以串列左移的技巧達成樹狀結構的窮舉法：
<img class="center" src="http://user-image.logdown.io/user/5845/blog/5862/post/202114/Zifq8ZN6RTOQpBrbSfR2_%E6%93%B7%E5%8F%96%E9%81%B8%E5%8F%96%E5%8D%80%E5%9F%9F_001.png" alt="Brute-force Search">

此外，必須使用非遞迴的程式寫法，若以遞迴很容易問題規模稍微大一點，就讓 stack 爆滿讓程式中止。畢竟 stack 預設只有 1MB 記憶體，像是一般 C 編譯器也都是預設 1MB。

## 設限
設限便是在分支時，依據問題的特性可以提早決定捨棄往下的所有節點，可以減少建立許多點：
<img class="center" src="http://user-image.logdown.io/user/5845/blog/5862/post/202114/xwmLpA3QSCjTEFUBBvo0_%E6%93%B7%E5%8F%96%E9%81%B8%E5%8F%96%E5%8D%80%E5%9F%9F_002.png" alt="B&amp;B">

由此可得知，問題特性必須要能**部份求解**才能用上設限技術。恰好 TSP 可以累加部份的路徑，求得當下累積的距離。若已高於目前最佳解的距離，便可跳過此節點及以下的所有子節點。因為再繼續建構這些解，也不會有更佳的解出現。

## 測試結果
我採用的是 TSPLIB 的 	[burma14][] 案例，共有 14 個點。`14!` 共有 `87,178,291,200` 個解。實作分支設限法並實驗後，僅需建立`252,835,082`個解（但未統計有多少部份解）。使用 AMD X4 620 2.6GHz 與 OpenJDK 7 x64，共花 `163` 秒。未使用分支設限法（也就是窮舉法）解同一問題，由於跑了幾十分鐘都跑不完，我就沒繼續等下去了（畢竟差了 3xx 倍）。

163 秒其實還有進步空間，接下來會盡可能縮短這時間，例如用上鍊結串列代替陣列，並使用**貪婪法**建立**種子解**讓更多節點可以跳過。

然而再怎麼進步也會到極限，像分支設限法這種**確切法**僅適合用在小規模上。我想超過 13 個節點，就必須改以**近似法**才能符合現實的需求。接著也會實作另一個**近似法**來搭配目前的分支設限法，依據用戶所要求的規模不同，自動切換兩種演算方法。

[burma14]: http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/tsp/burma14.tsp.gz
